# -*- coding: utf-8 -*-
"""Code3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XEwfVm8GjWnO5HpfBuf9ZF49N-6NjLi2
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px

# --- PAGE CONFIG ---
st.set_page_config(page_title="Institutional Fee Architect", page_icon="‚öñÔ∏è", layout="wide")

# --- CUSTOM CSS ---
st.markdown("""
    <style>
    .stMetric { background-color: #ffffff; padding: 15px; border-radius: 10px; border: 1px solid #eee; }
    .main { background-color: #f8f9fa; }
    .stButton>button { border-radius: 5px; background-color: #1e293b; color: white; }
    </style>
    """, unsafe_allow_html=True)

if 'years_count' not in st.session_state:
    st.session_state.years_count = 3

# --- SIDEBAR ---
with st.sidebar:
    st.title("‚öñÔ∏è Deal Terms")
    with st.expander("üíº Capital & Base Fees", expanded=True):
        initial_value = st.number_input("Initial Investment", value=1000000.0)
        base_mgmt = st.number_input("Mgmt Fee (%)", value=2.0) / 100
        mgmt_basis = st.selectbox("Fee Basis", ["Opening Balance", "Closing Balance"])

    with st.expander("üéØ Performance Structure", expanded=True):
        base_perf = st.number_input("Perf Fee (%)", value=20.0) / 100
        perf_basis = st.selectbox("Logic", ["Independent", "Net of Management Fee"])
        hurdle_rate = st.number_input("Hurdle Rate (%)", value=8.0) / 100
        hurdle_type = st.radio("Style", ["Hard Hurdle", "Soft Hurdle"], horizontal=True)
        use_hwm = st.toggle("High-Water Mark (HWM)", value=True)

    with st.expander("üî¨ Sensitivity"):
        step_size = st.slider("Step Size (%)", 0.1, 2.0, 0.5) / 100

st.title("Institutional Performance & Fee Architect")

# --- DYNAMIC GROWTH INPUTS ---
st.write("### üìÖ Annual Growth Projections")
c1, c2, _ = st.columns([1, 1, 8])
with c1:
    if st.button("‚ûï Add Year"): st.session_state.years_count += 1
with c2:
    if st.button("‚ûñ Remove Year") and st.session_state.years_count > 1: st.session_state.years_count -= 1

growth_rates = []
grid_cols = st.columns(5)
for i in range(st.session_state.years_count):
    with grid_cols[i % 5]:
        rate = st.number_input(f"Year {i+1} (%)", value=10.0, key=f"g_in_{i}")
        growth_rates.append(rate / 100)

# --- THE HERMETIC CALCULATION ENGINE ---
def run_full_simulation(g_list, m_rate, p_rate):
    sim_data = []
    c_opening = initial_value
    c_hwm = initial_value

    for idx, g in enumerate(g_list):
        gross_c = c_opening * (1 + g)
        m_fee = (c_opening if mgmt_basis == "Opening Balance" else gross_c) * m_rate

        h_amt = c_opening * hurdle_rate
        threshold = max(c_hwm, c_opening + h_amt) if use_hwm else (c_opening + h_amt)
        compare_val = (gross_c - m_fee) if perf_basis == "Net of Management Fee" else gross_c

        p_fee = 0.0
        if compare_val > threshold:
            if hurdle_type == "Hard Hurdle":
                p_fee = (compare_val - threshold) * p_rate
            else:
                p_base = c_hwm if use_hwm else c_opening
                p_fee = max(0, (compare_val - p_base) * p_rate)

        net_closing = gross_c - m_fee - p_fee

        sim_data.append({
            "Year": idx + 1,
            "Opening Bal": c_opening,
            "Growth (%)": g * 100, # STICKING TO THIS NAME
            "Mgmt Fee": m_fee,
            "Perf Fee": p_fee,
            "Net Closing": net_closing,
            "HWM": c_hwm if use_hwm else 0
        })

        if use_hwm: c_hwm = max(c_hwm, net_closing)
        c_opening = net_closing

    return pd.DataFrame(sim_data)

# --- EXECUTION ---
df_main = run_full_simulation(growth_rates, base_mgmt, base_perf)

# --- DASHBOARD METRICS ---
st.markdown("---")
f_net = df_main["Net Closing"].iloc[-1]
t_fees = df_main["Mgmt Fee"].sum() + df_main["Perf Fee"].sum()
cagr = ((f_net / initial_value)**(1/len(growth_rates)) - 1) * 100

m1, m2, m3, m4 = st.columns(4)
m1.metric("Final Net Value", f"${f_net:,.0f}")
m2.metric("Portfolio CAGR", f"{cagr:.2f}%")
m3.metric("Total Management Fees", f"${df_main['Mgmt Fee'].sum():,.0f}")
m4.metric("Total Performance Fees", f"${df_main['Perf Fee'].sum():,.0f}")

# --- VISUALS ---
v1, v2 = st.columns([7, 3])
with v1:
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df_main["Year"], y=df_main["Net Closing"], name="Net Value", line=dict(color='#1e293b', width=3), fill='tozeroy'))
    if use_hwm:
        fig.add_trace(go.Scatter(x=df_main["Year"], y=df_main["HWM"], name="Watermark", line=dict(color='#ef4444', dash='dot')))
    fig.update_layout(title="Capital Appreciation vs. High-Water Mark", template="simple_white", margin=dict(l=0, r=0, t=30, b=0))
    st.plotly_chart(fig, use_container_width=True)
with v2:
    fig_pie = px.pie(names=['Investor Profit', 'Total Fees'],
                     values=[max(0, f_net - initial_value), t_fees],
                     color_discrete_sequence=['#1e293b', '#cbd5e1'], hole=0.6)
    fig_pie.update_layout(showlegend=False, margin=dict(l=20, r=20, t=30, b=20))
    st.plotly_chart(fig_pie, use_container_width=True)

# --- DATA TABLE ---
st.write("### üìÑ Annual Performance Ledger")
# ERROR FIX: subset=["Growth (%)"] now matches the column name in the simulation function
st.dataframe(df_main.style.format(precision=2).background_gradient(subset=["Growth (%)"], cmap="RdYlGn"), use_container_width=True)

# --- SENSITIVITY ---
st.divider()
st.write("### üéØ Strategic Sensitivity Analysis")

shifts = [-2*step_size, -step_size, 0, step_size, 2*step_size]

def get_cagr_safe(g_list, m, p):
    # --- HARD ECONOMIC CONSTRAINTS ---
    safe_growth = [max(-0.99, g) for g in g_list]   # Growth cannot go below -100%
    safe_m = max(0.0, m)                            # Fees cannot be negative
    safe_p = max(0.0, p)

    df_temp = run_full_simulation(safe_growth, safe_m, safe_p)
    final_val = df_temp["Net Closing"].iloc[-1]

    return ((final_val / initial_value) ** (1 / len(safe_growth)) - 1) * 100


c1, c2, c3 = st.columns(3)

with c1:
    st.caption("Growth Sensitivity")
    s_g = pd.DataFrame({
        "Shift": [f"{s*100:+.1f}%" for s in shifts],
        "CAGR": [
            get_cagr_safe([g + s for g in growth_rates], base_mgmt, base_perf)
            for s in shifts
        ]
    })
    st.table(s_g.style.format(precision=2))


with c2:
    st.caption("Mgmt Fee Sensitivity")
    s_m = pd.DataFrame({
        "Shift": [f"{s*100:+.1f}%" for s in shifts],
        "CAGR": [
            get_cagr_safe(growth_rates, base_mgmt + s, base_perf)
            for s in shifts
        ]
    })
    st.table(s_m.style.format(precision=2))


with c3:
    st.caption("Perf Fee Sensitivity")
    s_p = pd.DataFrame({
        "Shift": [f"{s*100:+.1f}%" for s in shifts],
        "CAGR": [
            get_cagr_safe(growth_rates, base_mgmt, base_perf + s)
            for s in shifts
        ]
    })
    st.table(s_p.style.format(precision=2))


# --- 3-WAY STRESS MATRIX ---
st.write("#### 3-Way Stress Test: Growth vs. Performance Fee")

matrix = [
    [
        get_cagr_safe(
            [g + sg for g in growth_rates],
            base_mgmt,
            base_perf + sp
        )
        for sp in shifts
    ]
    for sg in shifts
]

df_matrix = pd.DataFrame(
    matrix,
    index=[f"Growth {s*100:+.1f}%" for s in shifts],
    columns=[f"Perf {s*100:+.1f}%" for s in shifts]
)

st.dataframe(
    df_matrix
    .style
    .background_gradient(cmap="RdYlGn")
    .format("{:.2f}%"),
    use_container_width=True
)